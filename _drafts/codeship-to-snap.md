---
layout: post
title:  "Moving from Codeship to Snap"
date:   2015-04-24
author: TBD
---

If you already use Codeship for continuous integration, you will be comfortable with many features of Snap. However, one of the first things you’ll notice when you begin using Snap is its pipeline. We created Snap’s continuous integration and delivery features around the use of pipelines. 

# Why Pipelines?

Simply put, we believe that pipelines are an essential part of any agile continuous integration and delivery process. By using a pipeline, you are able separate various integration and delivery tasks into stages. As you’d expect, your build progresses as each stage completes successfully. Likewise, your build stops if a stage fails.

Besides giving you a simple unit of control in a build, stages provide another key benefit: they give you the ability to find problems faster. 

# Use Pipelines for Agile Builds 

Typically, our users structure their pipelines so that a build’s early stages quickly discover most of the common problems they may encounter. Our users typically defer more complex and time-consuming tasks to later stages of the build. This way, a build process will fail fast. 

# A Closer Look at Pipeline Stages

Snap’s pipelines provide another benefit: the ability to fine-tune each stage independently of other stages. For example, you may want more workers allocated to a stage that performs a complex set of tasks. You can set the number of workers for that stage alone without increasing the number of workers allocated to other stages performing simple tasks.

In addition to tuning the number of workers, you can set environment variables, secure files to be used (such as SSH keys), and artifacts that will be generated by each stage. 

In Snap, you can also determine whether a stage should be executed automatically or with a manual trigger. This conforms to the principles of continuous delivery. In continuous delivery, you promise that your code can be deployed after a successful build, however you do not necessarily deploy code after each successful build. 

For example, you can create a build in which every stage runs automatically except for the final stage, during which you deploy your code into production environments. The final deployment stage would be manually triggered. This way, you could test and integrate code with each commit but only deploy code at the end of a sprint.

In this example, by using automatic and manual triggers you can use the same pipeline whether you plan to deploy your code or not.

# Reinforce Feedback and Encourage Learning with Build Histories

Once your pipeline is up and running against your repository, you’ll notice that you can review detailed histories of each build in Snap. Snap provides this feature because we think that tracking historical builds against each commit is a powerful way to reinforce feedback and encourage learning among your team. 

For even more granularity, you can review a detailed history of each build by pipeline stage, which shows exactly which commit affected the outcome of each stage in a build.

You’ll notice other differences between Codeship and Snap, but we hope this brief overview helps you understand some of the things you can do with Snap. Codeship helps teams get comfortable with continuous integration, and there are many benefits of using it. However, when you need to make your build processes more agile, check out how Snap’s pipelines can help.